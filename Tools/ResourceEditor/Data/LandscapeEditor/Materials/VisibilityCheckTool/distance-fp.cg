#include "common.cgh"
#include "blending.cgh"

FPROG_IN_BEGIN

#if defined(ENCODE_DISTANCE)
    FPROG_IN_TEXCOORD0(distanceToCamera,1)
#elif defined(DECODE_DISTANCE)
    FPROG_IN_TEXCOORD1(directionFromPoint,3)
#elif defined(REPROJECTION)
	FPROG_IN_TEXCOORD1(reprojectedCoords,4)
    FPROG_IN_TEXCOORD2(distanceToOrigin,1)
    FPROG_IN_TEXCOORD3(viewportCoords,4)
#endif

FPROG_IN_END

FPROG_OUT_BEGIN
    FPROG_OUT_COLOR
FPROG_OUT_END

const float4 decodeVector = float4(1.0, 255.0, 65025.0, 16581375.0);
const float encodeDecodeScale = 255.0;
const float MAGIC_TRESHOLD_2 = 1.0 / encodeDecodeScale;
const float MAGIC_TRESHOLD_1 = 1.0 + MAGIC_TRESHOLD_2;

float4 EncodeFloatRGBA(float v)
{
    v *= encodeDecodeScale;
	float4 result;
    result.x = fract(v); v = (v - result.x) / 255.0;
    result.y = fract(v); v = (v - result.y) / 255.0;
    result.z = fract(v); v = (v - result.z) / 255.0;
    result.w = fract(v);
	return result;
}

float DecodeFloatRGBA(float4 encoded)
{
	return dot(encoded, decodeVector) / encodeDecodeScale;
}

#if defined(DECODE_DISTANCE)

DECL_FP_SAMPLERCUBE(cubemap)

property float4 flatColor : static,a : ;
property float3 transformedNormal : static,a : ;
property float3 pointProperties : static,a : ;

#elif defined(REPROJECTION)

DECL_FP_SAMPLER2D(fixedFrame)
DECL_FP_SAMPLER2D(fixedFrameDistances)
DECL_FP_SAMPLER2D(currentFrame)

property float2 viewportSize : static,a : ;
property float currentFrameCompleteness : static,a : ;

#endif

FPROG_BEGIN

#if defined(PRERENDER)

	FP_OUT_COLOR = float4(0.0, 0.0, 0.0, 0.0);

#elif defined(ENCODE_DISTANCE)

	FP_OUT_COLOR = EncodeFloatRGBA(FP_IN(distanceToCamera));

#elif defined(DECODE_DISTANCE)

	float4 sampledDistance = FP_TEXTURECUBE(cubemap, FP_IN(directionFromPoint));
	float decodedDistance = DecodeFloatRGBA(sampledDistance);
	float actualDistance = length(FP_IN(directionFromPoint));
	float occluded = float(actualDistance / decodedDistance <= MAGIC_TRESHOLD_1);
	
	float3 nDir = normalize(FP_IN(directionFromPoint));
	float DdotN = dot(nDir, transformedNormal);
	float angleLimit = float(clamp(DdotN, pointProperties.x, pointProperties.y) == DdotN);
	float distanceLimit = step(actualDistance, pointProperties.z);
	FP_OUT_COLOR = flatColor * (distanceLimit * occluded * angleLimit);

#elif defined(REPROJECTION)

	float2 vpCoords = 0.5 + 0.5 * FP_IN(viewportCoords).xy / FP_IN(viewportCoords).w;
	float2 vp = viewportSize * vpCoords;

    float cx = float(int(vp.x) / 4);
    float cy = float(int(vp.y) / 4);
    vec4 checkboard = vec4(0.25 * mod(cx + mod(cy, 2.0), 2.0));

	float3 reprojectedUVW = 0.5 + 0.5 * FP_IN(reprojectedCoords).xyz / FP_IN(reprojectedCoords).w;
	float4 sampledColor = FP_TEXTURE2D(fixedFrame, reprojectedUVW.xy);
	float4 currentColor = mix(checkboard, FP_TEXTURE2D(currentFrame, vpCoords), currentFrameCompleteness);

	float sampledDistance = DecodeFloatRGBA(FP_TEXTURE2D(fixedFrameDistances, reprojectedUVW.xy));
	float actualDistance = FP_IN(distanceToOrigin);
	float visibleInProjection = 1.0 - float(abs(actualDistance / sampledDistance - 1.0) > MAGIC_TRESHOLD_2);
	float insideProjection = float(all(equal(reprojectedUVW, clamp(reprojectedUVW, float3(0.0), float3(1.0)))));

	FP_OUT_COLOR = mix(currentColor, sampledColor, insideProjection * visibleInProjection);

#else
#	error Undefined
#endif

FPROG_END
