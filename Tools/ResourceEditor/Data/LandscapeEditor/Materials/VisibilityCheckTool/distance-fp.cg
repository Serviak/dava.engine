#include "common.cgh"
#include "blending.cgh"

FPROG_IN_BEGIN

#if defined(ENCODE_DISTANCE)
    FPROG_IN_TEXCOORD0(distanceToCamera,1)
#endif

#if defined(DECODE_DISTANCE)
    FPROG_IN_TEXCOORD1(directionFromPoint,3)
#endif

FPROG_IN_END

FPROG_OUT_BEGIN
    FPROG_OUT_COLOR
FPROG_OUT_END

#if defined(ENCODE_DISTANCE)
float4 EncodeFloatRGBA(float v) 
{
	float4 result;
	result.x = modf(v, v); 
	result.y = modf(v / 255.0, v);
	result.z = modf(v / 255.0, v);
	result.w = modf(v / 255.0, v);
	return result;
}
#endif

#if defined(DECODE_DISTANCE)
DECL_FP_SAMPLERCUBE(cubemap)

const float4 decodeVector = float4(1.0, 255.0, 65025.0, 16581375.0);

float DecodeFloatRGBA(float4 encoded)
{
	return dot(encoded, decodeVector);
}
#endif

#define MAGIC_TRESHOLD 1.001

FPROG_BEGIN

#if defined(DECODE_DISTANCE)
	property float4 flatColor : static,a : ;
	property float3 transformedNormal : static,a : ;
	property float3 pointProperties : static,a : ;
#endif

#if defined(ENCODE_DISTANCE)
	FP_OUT_COLOR = EncodeFloatRGBA(FP_IN(distanceToCamera));
#endif

#if defined(DECODE_DISTANCE)
	float4 sampledDistance = FP_TEXTURECUBE(cubemap, FP_IN(directionFromPoint));
	float decodedDistance = DecodeFloatRGBA(sampledDistance);
	float actualDistance = length(FP_IN(directionFromPoint));
	float occluded = float(actualDistance / decodedDistance <= MAGIC_TRESHOLD);
	
	float3 nDir = normalize(FP_IN(directionFromPoint));
	float DdotN = dot(nDir, transformedNormal);
	float angleLimit = float(clamp(DdotN, pointProperties.x, pointProperties.y) == DdotN);
	float distanceLimit = step(actualDistance, pointProperties.z);
	FP_OUT_COLOR = flatColor * (distanceLimit * occluded * angleLimit);
#endif

#if defined(PRERENDER)
	FP_OUT_COLOR = float4(0.0, 0.0, 0.0, 0.0);
#endif

FPROG_END
