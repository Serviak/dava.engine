#include "common.cgh"
#include "blending.cgh"

FPROG_IN_BEGIN

#if defined(ENCODE_DISTANCE)
    FPROG_IN_TEXCOORD0(distanceToCamera,1)
#endif

#if defined(DECODE_DISTANCE)
    FPROG_IN_TEXCOORD1(directionFromPoint,3)
#endif

FPROG_IN_END

FPROG_OUT_BEGIN
    FPROG_OUT_COLOR
FPROG_OUT_END

const float encX = 1.0;
const float encY = 1.0 / 255.0;
const float encZ = 1.0 / 65025.0;
const float encW = 1.0 / 16581375.0;

#if defined(ENCODE_DISTANCE)
float4 EncodeFloatRGBA(float v) 
{
	float4 result;
	result.x = fract(v);
	v = (v - result.x) / 255.0;

	result.y = fract(v);
	v = (v - result.y) / 255.0;

	result.z = fract(v);
	v = (v - result.z) / 255.0;

	result.w = fract(v);

	return result;
}
#endif

#if defined(DECODE_DISTANCE)
DECL_FP_SAMPLERCUBE(cubemap)

float DecodeFloatRGBA(float4 encoded)
{
	return encoded.x + 
		encoded.y * 255.0 + 
		encoded.z * 255.0 * 255.0 +
		encoded.w * 255.0 * 255.0 * 255.0;
}
#endif

#define MAGIC_TRESHOLD 1.001

FPROG_BEGIN

#if defined(DECODE_DISTANCE)
	property float4 flatColor : static,a : ;
	property float3 transformedNormal : static,a : ;
	property float2 verticalAngles : static,a : ;
#endif

#if defined(ENCODE_DISTANCE)
	FP_OUT_COLOR = EncodeFloatRGBA(FP_IN(distanceToCamera));
#endif

#if defined(DECODE_DISTANCE)
	float4 sampledDistance = FP_TEXTURECUBE(cubemap, FP_IN(directionFromPoint));
	float decodedDistance = DecodeFloatRGBA(sampledDistance);
	float actualDistance = length(FP_IN(directionFromPoint));
	float occluded = float(actualDistance / decodedDistance < MAGIC_TRESHOLD);
	
	float3 nDir = normalize(FP_IN(directionFromPoint));
	float DdotN = dot(nDir, transformedNormal);
	float angleLimit = float(clamp(DdotN, verticalAngles.y, verticalAngles.x) == DdotN);
	FP_OUT_COLOR = flatColor * (occluded * angleLimit);
#endif

#if defined(PRERENDER)
	FP_OUT_COLOR = float4(0.0, 0.0, 0.0, 0.0);
#endif

FPROG_END
