#include "common.cgh"

#if USE_INSTANCING

	VPROG_IN_BEGIN
		VPROG_IN_STREAM_VERTEX
			VPROG_IN_TEXCOORD0(4) //position + edgeShiftDirection
			VPROG_IN_TEXCOORD1(4) //edge mask
			VPROG_IN_TEXCOORD2(2) //edgeVertexIndex + edgeMaskNull
		VPROG_IN_STREAM_INSTANCE
			VPROG_IN_TEXCOORD3(3) //patch position + scale
			VPROG_IN_TEXCOORD4(4) //near patch lodOffset
		#if LOD_MORPHING
			VPROG_IN_TEXCOORD5(4) //near patch morph
			VPROG_IN_TEXCOORD6(3) //patch lod + morph + pixelMappingOffset
		#endif
	VPROG_IN_END
	
#else
	
	VPROG_IN_BEGIN
		VPROG_IN_POSITION
		VPROG_IN_TEXCOORD
	VPROG_IN_END
	
#endif

VPROG_OUT_BEGIN
    
    VPROG_OUT_POSITION
    VPROG_OUT_TEXCOORD0(texCoord,2)
    #if TILEMASK
        VPROG_OUT_TEXCOORD1(texCoordTiled,2)
    #endif

    #if VERTEX_FOG
        VPROG_OUT_TEXCOORD5(varFog,4)
    #endif

VPROG_OUT_END

#if USE_INSTANCING
	DECL_VP_SAMPLER2D(heightmap)
#endif

property float4x4 worldViewProjMatrix          : dynamic,a : ;

#if USE_INSTANCING
	property float3 boundingBoxSize 		   : dynamic,a : ;
#endif

#if TILEMASK
    property float2   textureTiling 		   : static,instance : def_value=50,50;
#endif

#if VERTEX_FOG
property float4x4 worldMatrix                  : dynamic,a : ;
property float4x4 worldViewMatrix              : dynamic,a : ;
property float3   cameraPosition               : dynamic,a : ;
#endif
#if VERTEX_FOG && FOG_ATMOSPHERE
property float4   lightPosition0               : dynamic,a : ;
#endif

#include "vp-fog-props.cgh"

VPROG_BEGIN

#if USE_INSTANCING

    float2 in_pos = VP_IN_TEXCOORD0.xy; //Относительные координаты вершины в пространстве патча. [0.0, 1.0]
    float2 edgeShiftDirection = VP_IN_TEXCOORD0.zw; //Вектор направления сдвига вершины для сшивания патчей разных лодов. Актуально только для вершин на ребрах патча. Направлен в сторону вершины с 0-ым индексом (см ниже). Длина равна 1.0 / QUADS_IN_PATCH_COUNT.
    float4 edgeMask = VP_IN_TEXCOORD1; //Маска принадлежности вершины какому-либо ребру патча (л, в, п, н). Содержит максимум одну единицу. Для внутренних и угловых вершин маска нулевая.
	float edgeVertexIndex = VP_IN_TEXCOORD2.x; //Индекс вершины на ребре. #0 - один угол, #16 - другой. Необходимо для высчитывания смещения вершины для сшивания лодов. У внутренних вершин - всегда нулевой.
	
    float3 patchOffsetScale = VP_IN_TEXCOORD3.xyz; //Позиция (x, y) и масштаб (z) патча в относительных числах в пространстве ландшафта.
	float4 nearPatchLodOffset = VP_IN_TEXCOORD4; //Разница номеров соседних лодов относительно текущего патча. Значение компонентов вектора соотвествует edgeMask. 
	
	float lodOffset = dot(edgeMask, nearPatchLodOffset); //Высчитываем сдвиг лода для текущей вершины. Для углов и внутренних вершин всегда 0. 
    float edgeShiftAmount = pow(2.0, lodOffset); //'Модуль' смещения вершин на ребрах. Например, "4" означает, что каждая 4-я вершина ребра остаётся на месте, остальные сдвигаются на остаток от деления.
	in_pos += edgeShiftDirection * fmod(edgeVertexIndex, edgeShiftAmount); //fmod возвращает смещение в 'квадаратах'. Длина вектора 'edgeShiftDirection' даёт смещение в относительных координатах (в пространстве патча).
	
    float2 relativePosition = patchOffsetScale.xy + in_pos.xy * patchOffsetScale.z; //Высчитываем координаты вершины в пространстве ландшафта (если угодно - карты высот).
	
#if LOD_MORPHING
	
	float edgeMaskNull = VP_IN_TEXCOORD2.y; //0.0 - если маска ребер нулевая, 1.0 в притивном случае. Используется для легкой оптимизации расчётов.
	float4 nearPatchMorph = VP_IN_TEXCOORD5; //Значение morph-коэффициента соседних патчей. Каждое из значение от 0.0 до 1.0.
	
	float baseLod = VP_IN_TEXCOORD6.x; //Номер лода текущего патча.
	float patchMorph = VP_IN_TEXCOORD6.y; //morph-коефициент текущего патча.
	float basePixelOffset = VP_IN_TEXCOORD6.z; //Смещение на пол-текселя для текущего mip-уровня текстуры. Высчитывается как 0.5 / ( 2 ^ baseLod ).
	
	
	float2 zeroLod = STEP(1.0, relativePosition); //'Вычленяем' крайние вершины ландшафта с тех двух сторон, где крайние вершины вылазят за текстуру. Эти вершины должны фетчить 0-вой mip.
	float zeroLodMul = 1.0 - min(1.0, zeroLod.x + zeroLod.y); //'Множитель' для зануления номера mip'a в дальнейшем. Равен 0.0, если хотябы одна из компонент позиции вершины равна 1.0

	float sampleLod = (baseLod + lodOffset) * zeroLodMul; //Высчитывается mip-уровень, из которого нужно фетчить. Может зануляться для крайних вершин ландшафта.
	float samplePixelOffset = basePixelOffset * edgeShiftAmount * zeroLodMul; //Смещение на пол-текселя. Умножение на 'edgeShiftAmount' даёт 0.5 / ( 2 ^ ( baseLod + lodOffset ) ). Может зануляться для крайних вершин ландшафта.
	float4 heightmapSample = VP_TEXTURE2D(heightmap, relativePosition + samplePixelOffset, sampleLod); //Фетч.
	
	float morphAmount = dot(edgeMask, nearPatchMorph) + patchMorph * edgeMaskNull; //Высчитывается значение morphing'а. Для вершин на рёбрах берется из значений соседних патчей, для угловых и внутренних - равен значению текущего патча.
	
	//Высчитываем итоговую высоту вершины. Текстура RGBA8888. В текстуре хранится два значения высоты. Первые 16 бит (RG) содержат точное значение высоты для текущего лода.
	//Вторые 16 бит (BA) содержат значение высоты следущего лода. Причём значение высоты 'между вершинами' усреднено, что позволяет разместить промежуточные вершины текущего лода ровно по середине ребер треугольников следующего лода. 
	// float h0 = dot(heightmapSample.xy, float2(0.0038910506, 0.99610895)); //Конвертируем 16 бит в одно значение. RG - точная высота
	// float h1 = dot(heightmapSample.zw, float2(0.0038910506, 0.99610895)); //BA - 'усредненная' высота.
	// float height = lerp(h1, h0, morphAmount); //Интерполируем два значения по morph-коэффициенту. 0.0 - меньшая детализация, 1.0 - бОльшая детализация.
	
	//Код ниже делает тоже самое, что описано выше, но только за потенциально-меньшее количество умножений. Итоговое значение высоты в диапазоне [0.0, 1.0].
	float2 hmSampleMorphed = lerp(heightmapSample.zw, heightmapSample.xy, morphAmount);
	float height = dot(hmSampleMorphed, float2(0.0038910506, 0.99610895));
	
#else
	
	float4 heightmapSample = VP_TEXTURE2D(heightmap, relativePosition, 0.0); //В варианте без морфинга просто фетчим высоту из текстуры
	float height = dot(heightmapSample, float4(0.00022888532845, 0.00366216525521, 0.05859464408331, 0.93751430533303)); //Текстура RGBA4444, константами конвертируем 16 bit в значение от 0.0 до 1.0
	
#endif

    float3 vx_position = float3( relativePosition - 0.5, height ) * boundingBoxSize; //Переводим координаты вершины из относительных в мировые ландшафта.
	
    VP_OUT_POSITION = mul( float4(vx_position.x, vx_position.y, vx_position.z, 1.0), worldViewProjMatrix );
    VP_OUT(texCoord) = float2(relativePosition.x, 1.0 - relativePosition.y);
	 
#else
	
	float3 vx_position = VP_IN_POSITION.xyz;
    
    VP_OUT_POSITION = mul( float4(vx_position.x, vx_position.y, vx_position.z, 1.0), worldViewProjMatrix );
	VP_OUT(texCoord) = VP_IN_TEXCOORD;
	
#endif
	
#if TILEMASK
    VP_OUT(texCoordTiled) = VP_OUT(texCoord) * textureTiling.xy;
#endif
	
#if VERTEX_FOG
	
	float3 view_position = mul( float4(vx_position.xyz,1.0), worldViewMatrix ).xyz;
	#define FOG_view_position view_position
	
#if FOG_ATMOSPHERE
	float3 tolight_dir = lightPosition0.xyz - view_position * lightPosition0.w;
    #define FOG_to_light_dir tolight_dir
#endif
	
#if FOG_HALFSPACE || FOG_ATMOSPHERE_MAP
	float3 world_position = mul( float4(vx_position.xyz,1.0), worldMatrix ).xyz;
	#define FOG_world_position world_position
#endif

    #define FOG_eye_position cameraPosition

	#include "vp-fog-math.cgh" // in{ float3 FOG_view_position, float3 FOG_eye_position, float3 FOG_to_light_dir, float3 FOG_world_position }; out{ float4 FOG_result };
	
	VP_OUT(varFog) = FOG_result;
	
#endif
    
VPROG_END
