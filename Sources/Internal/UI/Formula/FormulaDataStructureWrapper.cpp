#include "FormulaDataStructureWrapper.h"

#include "Debug/DVAssert.h"

#include "UI/Formula/FormulaData.h"

#include "Reflection/Reflection.h"
#include "Reflection/ReflectedStructure.h"
#include "Reflection/ReflectedTypeDB.h"
#include "Reflection/Private/Wrappers/StructureWrapperClass.h"
#include "Reflection/ReflectionRegistrator.h"

namespace DAVA
{
    using std::shared_ptr;
    using std::make_shared;
    
    FormulaDataStructureWrapper::FormulaDataStructureWrapper()
    {
    }
    
    FormulaDataStructureWrapper::~FormulaDataStructureWrapper() = default;
    
    Reflection FormulaDataStructureWrapper::CreateReflection(Any &val) const
    {
        if (val.IsEmpty())
        {
            return Reflection();
        }
        else if (val.CanGet<shared_ptr<FormulaDataMap>>())
        {
            return Reflection::Create(ReflectedObject(val.Get<shared_ptr<FormulaDataMap>>().get()));
        }
        else if (val.CanGet<shared_ptr<FormulaDataVector>>())
        {
            return Reflection::Create(ReflectedObject(val.Get<shared_ptr<FormulaDataVector>>().get()));
        }
        
        return Reflection::Create(&val);
    }
    
    FormulaDataVectorStructureWrapper::FormulaDataVectorStructureWrapper()
    {
        caps.canAddField = false;
        caps.canInsertField = false;
        caps.canRemoveField = false;
        caps.hasFlatStruct = true;
        caps.hasAutogeneratedKeys = true;
        caps.flatKeysType = Type::Instance<size_t>();
        caps.flatValuesType = Type::Instance<Any>();
    }
    
    FormulaDataVectorStructureWrapper::~FormulaDataVectorStructureWrapper()
    {
    }
    
    bool FormulaDataVectorStructureWrapper::HasFields(const ReflectedObject& object, const ValueWrapper* vw) const
    {
        FormulaDataVector *data = vw->GetValueObject(object).GetPtr<FormulaDataVector>();
        return !data->IsEmpty();
    }
    
    Reflection FormulaDataVectorStructureWrapper::GetField(const ReflectedObject& obj, const ValueWrapper* vw, const Any& key) const
    {
        FormulaDataVector *data = vw->GetValueObject(obj).GetPtr<FormulaDataVector>();
        return CreateReflection(data->Get(key.Cast<size_t>()));
    }
    
    Vector<Reflection::Field> FormulaDataVectorStructureWrapper::GetFields(const ReflectedObject& obj, const ValueWrapper* vw) const
    {
        Vector<Reflection::Field> fields;
        FormulaDataVector *data = vw->GetValueObject(obj).GetPtr<FormulaDataVector>();
        
        for (size_t index = 0; index < data->GetCount(); index++)
        {
            fields.emplace_back(index, CreateReflection(data->Get(index)), nullptr);
        }
        
        return fields;
    }
    
    FormulaDataMapStructureWrapper::FormulaDataMapStructureWrapper()
    {
        caps.canAddField = false;
        caps.canRemoveField = false;
        caps.hasFlatStruct = false;
        caps.hasDynamicStruct = true;
        caps.flatKeysType = Type::Instance<String>();
        caps.flatValuesType = Type::Instance<Any>();
    }
    
    FormulaDataMapStructureWrapper::~FormulaDataMapStructureWrapper()
    {
    }
    
    bool FormulaDataMapStructureWrapper::HasFields(const ReflectedObject& object, const ValueWrapper* vw) const
    {
        FormulaDataMap *data = vw->GetValueObject(object).GetPtr<FormulaDataMap>();
        return !data->IsEmpty();
    }
    
    Reflection FormulaDataMapStructureWrapper::GetField(const ReflectedObject& obj, const ValueWrapper* vw, const Any& key) const
    {
        FormulaDataMap *data = vw->GetValueObject(obj).GetPtr<FormulaDataMap>();
        return CreateReflection(data->Find(key.Cast<String>()));
    }
    
    Vector<Reflection::Field> FormulaDataMapStructureWrapper::GetFields(const ReflectedObject& obj, const ValueWrapper* vw) const
    {
        Vector<Reflection::Field> fields;
        FormulaDataMap *data = vw->GetValueObject(obj).GetPtr<FormulaDataMap>();
        
        for (const String &key : data->GetOrderedKeys())
        {
            fields.emplace_back(key, CreateReflection(data->Find(key)), nullptr);
        }
        
        return fields;
    }
    
}
