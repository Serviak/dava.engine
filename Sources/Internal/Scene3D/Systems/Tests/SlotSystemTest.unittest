#include "UnitTests/UnitTests.h"

#include "Scene3D/Scene.h"
#include "Scene3D/Entity.h"
#include "Scene3D/Components/SlotComponent.h"
#include "Scene3D/Systems/SlotSystem.h"
#include "Engine/Engine.h"
#include "Render/Texture.h"
#include "FileSystem/FilePath.h"
#include "Base/RefPtr.h"
#include "Base/FastName.h"

DAVA_TESTCLASS (SlotSystemTests)
{
    void ValidateParseResult(const DAVA::Vector<DAVA::SlotSystem::ItemsCache::Item>& items)
    {
        bool testItem1Found = false;
        bool testItem2Found = false;
        for (const DAVA::SlotSystem::ItemsCache::Item& item : items)
        {
            if (item.itemName == DAVA::FastName("TestItem1"))
            {
                testItem1Found = true;
                TEST_VERIFY(item.scenePath == DAVA::FilePath("~res:/3d/Maps/SlotItem/tree_k2_test3.sc2"));
                TEST_VERIFY(item.type == DAVA::FastName("SimpleItem"));
            }
            else if (item.itemName == DAVA::FastName("TestItem2"))
            {
                testItem2Found = true;
                TEST_VERIFY(item.scenePath == DAVA::FilePath("~res:/3d/Maps/SlotItem/big01.sc2"));
                TEST_VERIFY(item.type == DAVA::FastName("Test"));
            }
        }

        TEST_VERIFY(testItem1Found == true);
        TEST_VERIFY(testItem2Found == true);
    }

    DAVA_TEST(ConfigParseTest)
    {
        DAVA::RefPtr<DAVA::Scene> scene;
        scene.ConstructInplace();

        {
            DAVA::Vector<DAVA::SlotSystem::ItemsCache::Item> items = scene->slotSystem->GetItems(DAVA::FilePath("~res:/TestData/SlotSystemTest/slotConfig.yaml"));
            ValidateParseResult(items);
        }

        {
            DAVA::Vector<DAVA::SlotSystem::ItemsCache::Item> items = scene->slotSystem->GetItems(DAVA::FilePath("~res:/TestData/SlotSystemTest/slotConfig.xml"));
            ValidateParseResult(items);
        }
    }

    DAVA_TEST (LoadItemsTest)
    {
        using namespace DAVA;
        TEST_VERIFY(testScene.Get() == nullptr);
        testScene.ConstructInplace();

        Vector<SlotComponent*> components;

        {
            RefPtr<Entity> aEntity;
            aEntity.ConstructInplace();

            SlotComponent* alfaComponent = new SlotComponent();
            alfaComponent->SetSlotName(FastName("TestSlot"));
            alfaComponent->SetConfigFilePath(FilePath("~res:/TestData/SlotSystemTest/slotConfig.yaml"));
            alfaComponent->SetAttachmentTransform(Matrix4::MakeRotation(Vector3(1.0f, 0.0f, 0.5f), 0.3f) * Matrix4::MakeTranslation(Vector3(30.0f, 25.0f, 0.0f)));
            aEntity->AddComponent(alfaComponent);
            components.push_back(alfaComponent);
            testScene->AddNode(aEntity.Get());

        }

        {
            RefPtr<Entity> bEntity;
            bEntity.ConstructInplace();

            SlotComponent* betaComponent = new SlotComponent();
            betaComponent->SetSlotName(FastName("TestSlot"));
            betaComponent->SetConfigFilePath(FilePath("~res:/TestData/SlotSystemTest/slotConfig.xml"));
            betaComponent->SetAttachmentTransform(Matrix4::MakeRotation(Vector3(1.0f, 0.0f, 0.5f), 0.3f) * Matrix4::MakeTranslation(Vector3(35.0f, 25.0f, 0.0f)));
            bEntity->AddComponent(betaComponent);
            components.push_back(betaComponent);

            SlotComponent* gammaComponent = new SlotComponent();
            gammaComponent->SetSlotName(FastName("SecondTestSlot"));
            gammaComponent->SetConfigFilePath(FilePath("~res:/TestData/SlotSystemTest/slotConfig.xml"));
            gammaComponent->SetAttachmentTransform(Matrix4::MakeRotation(Vector3(2.0f, 0.0f, 0.5f), 0.3f) * Matrix4::MakeTranslation(Vector3(35.0f, 25.0f, 0.0f)));
            bEntity->AddComponent(gammaComponent);
            components.push_back(gammaComponent);
            testScene->AddNode(bEntity.Get());
        }

        for (SlotComponent* component : components)
        {
            TEST_VERIFY(testScene->slotSystem->LookUpLoadedEntity(component) == nullptr);
        }

        testScene->slotSystem->AttachItemToSlot(testScene.Get(), FastName("TestSlot"), FastName("TestItem1"));
        testScene->slotSystem->AttachItemToSlot(testScene.Get(), FastName("SecondTestSlot"), FastName("TestItem2"));

        for (SlotComponent* component : components)
        {
            TEST_VERIFY(testScene->slotSystem->LookUpLoadedEntity(component) != nullptr);
        }
    }

    void Update(DAVA::float32 timeElapsed, const DAVA::String& testName) override
    {
        if (testScene.Get() != nullptr)
        {
            testScene->Update(timeElapsed);
        }
        testTime += timeElapsed;
    }

    bool ValidateLoadedItem(DAVA::Entity* rootEntity, DAVA::SlotComponent* component, const DAVA::FastName& subItemName) const
    {
        using namespace DAVA;
        for (int32 i = 0; i < rootEntity->GetChildrenCount(); ++i)
        {
            Entity* itemEntity = rootEntity->GetChild(i);
            if (itemEntity->GetName() == component->GetSlotName())
            {
                TEST_VERIFY(testScene->slotSystem->LookUpLoadedEntity(component) == itemEntity);
                TEST_VERIFY(testScene->slotSystem->LookUpSlot(itemEntity) == component);

                if (itemEntity->GetLocalTransform() == component->GetAttachmentTransform())
                {
                    if (itemEntity->GetChildrenCount() == 1)
                    {
                        DAVA::Entity* loadedSceneEntity = itemEntity->GetChild(0);
                        TEST_VERIFY(loadedSceneEntity->GetName() == subItemName);
                        return true;
                    }
                }
            }
        }

        return false;
    }

    bool TestComplete(const DAVA::String& testName) const override
    {
        if (testName == "LoadItemsTest")
        {
            TEST_VERIFY(testTime < 10.0f);
            TEST_VERIFY(testScene->GetChildrenCount() == 2);
            DAVA::Entity* aEntity = testScene->GetChild(0);

            TEST_VERIFY(aEntity->GetComponentCount(DAVA::Component::SLOT_COMPONENT) == 1);
            DAVA::SlotComponent* alfaComponent = static_cast<DAVA::SlotComponent*>(aEntity->GetComponent(DAVA::Component::SLOT_COMPONENT, 0));
            bool result = ValidateLoadedItem(aEntity, alfaComponent, DAVA::FastName("tree_k2_test3"));

            DAVA::Entity* bEntity = testScene->GetChild(1);
            TEST_VERIFY(bEntity->GetComponentCount(DAVA::Component::SLOT_COMPONENT) == 2);
            DAVA::SlotComponent* betaComponent = static_cast<DAVA::SlotComponent*>(bEntity->GetComponent(DAVA::Component::SLOT_COMPONENT, 0));
            DAVA::SlotComponent* gamaComponent = static_cast<DAVA::SlotComponent*>(bEntity->GetComponent(DAVA::Component::SLOT_COMPONENT, 1));

            result &= ValidateLoadedItem(bEntity, betaComponent, DAVA::FastName("tree_k2_test3"));
            result &= ValidateLoadedItem(bEntity, gamaComponent, DAVA::FastName("BigPlant01"));

            return result;
        }

        return true;
    }

    void SetUp(const DAVA::String& testName) override
    {
        gpuOrder = DAVA::Texture::GetGPULoadingOrder();
        DAVA::Vector<DAVA::eGPUFamily> newOrder;
        newOrder.push_back(DAVA::GPU_ORIGIN);
        DAVA::Texture::SetGPULoadingOrder(newOrder);
    }

    void TearDown(const DAVA::String& testName) override
    {
        DAVA::Texture::SetGPULoadingOrder(gpuOrder);
        testScene = DAVA::RefPtr<DAVA::Scene>();
        testTime = 0.0;
    }

    DAVA::Vector<DAVA::eGPUFamily> gpuOrder;
    DAVA::RefPtr<DAVA::Scene> testScene;
    DAVA::float32 testTime;
};
