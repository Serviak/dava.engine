#include "common.cgh"

VPROG_IN_BEGIN
    VPROG_IN_POSITION
    
    VPROG_IN_NORMAL    
    VPROG_IN_TANGENT
    
    VPROG_IN_TEXCOORD0(2)
    VPROG_IN_TEXCOORD1(2)        
VPROG_IN_END

VPROG_OUT_BEGIN
    VPROG_OUT_POSITION
    VPROG_OUT_TEXCOORD0(uv,2)
    VPROG_OUT_TEXCOORD1(uv1,2)
    VPROG_OUT_TEXCOORD2(cameraToPointInTangentSpace, 3)
    VPROG_OUT_TEXCOORD3(eyeDist, 3)
    VPROG_OUT_TEXCOORD4(normalizedFragPos, 4)
    
VPROG_OUT_END

property float4 lightPosition0 : dynamic,instance : ;
property float4x4 worldViewProjMatrix : dynamic,instance : ui_hidden=yes ;
property float4x4 worldViewInvTransposeMatrix : dynamic,instance : ;
property float4x4 worldViewMatrix : dynamic,instance : ;
property float globalTime : dynamic,instance : ;

property float2 normal0ShiftPerSecond : static,instance : ; 
property float2 normal1ShiftPerSecond : static,instance : ;
property float normal0Scale : static,instance : ;
property float normal1Scale : static,instance : ;

#if MATERIAL_LIGHTMAP
property float2 uvOffset : static,instance : ui_hidden=yes ;
property float2 uvScale : static,instance : ui_hidden=yes ;
#endif

VPROG_BEGIN
    float3 in_pos      = VP_IN_POSITION;    
    float4 inPosition = float4(in_pos, 1.0);    
    float4 resPosition = mul( inPosition, worldViewProjMatrix );
    VP_OUT_POSITION   = resPosition;
    VP_OUT(normalizedFragPos) = resPosition;//.xy/resPosition.w;
    
    float3 eyeCoordsPosition = mul (inPosition, worldViewMatrix ).xyz;
    VP_OUT(eyeDist) = eyeCoordsPosition;
    
    float3  inNormal    = VP_IN_NORMAL;
    float3  inTangent   = VP_IN_TANGENT;
    
    float3 n = normalize( mul( float4(inNormal,1.0), worldViewInvTransposeMatrix ).xyz );
    float3 t = normalize( mul( float4(inTangent,1.0), worldViewInvTransposeMatrix ).xyz );
    float3 b = cross (n, t);

    float3 v;
    v.x = dot (eyeCoordsPosition, t);
    v.y = dot (eyeCoordsPosition, b);
    v.z = dot (eyeCoordsPosition, n);
    VP_OUT(cameraToPointInTangentSpace) = v;
    
    

    VP_OUT(uv) =  VP_IN_TEXCOORD;
    VP_OUT(uv1) = VP_IN_TEXCOORD1;
    float2 inTexCoord0 = VP_IN_TEXCOORD;
    float2 inTexCoord1 = VP_IN_TEXCOORD1;
    VP_OUT(uv) = inTexCoord0 * normal0Scale + normal0ShiftPerSecond * globalTime;
    #if SEPARATE_NORMALMAPS
        #if DEBUG_NORMAL_ROTATION
            float rota = normalRotation/180.0*3.1415;        
            float cr = cos(rota);
            float sr = sin(rota);
            float2 rotatedTC = float2(inTexCoord0.x * cr + inTexCoord0.y * sr, inTexCoord0.x * sr - inTexCoord0.y * cr);
            VP_OUT(uv1) = rotatedTC * normal1Scale + normal1ShiftPerSecond * globalTime;
        #else            
            VP_OUT(uv1) = inTexCoord0 * normal1Scale + normal1ShiftPerSecond * globalTime;
        #endif
    #else
        VP_OUT(uv1) = float2(inTexCoord0.x+inTexCoord0.y, inTexCoord0.x-inTexCoord0.y) * normal1Scale + normal1ShiftPerSecond * globalTime;
    #endif
    

    
VPROG_END
