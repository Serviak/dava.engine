#define MAX_JOINTS 32
#define _PI 3.141592654
/*
#if defined FOG_ATMOSPHERE
    #if !defined DISTANCE_ATTENUATION
    #define DISTANCE_ATTENUATION
    #endif
#endif
*/


#if defined VERTEX_FOG
#undef VERTEX_FOG
#endif

#if defined WIND_ANIMATION  &&  WIND_ANIMATION == 0
    #undef WIND_ANIMATION
#endif

#if defined FOG_LINEAR  &&  FOG_LINEAR == 0
    #undef FOG_LINEAR
#endif



////////////////////////////////////////////////////////////////////////////////
// vprog-input

VPROG_IN_BEGIN
    
    VPROG_IN_POSITION
    
    #if defined(VERTEX_LIT) || defined(PIXEL_LIT)
    VPROG_IN_NORMAL
    #endif

    #if defined(MATERIAL_SKYBOX)
    VPROG_IN_TEXCOORD0(3)
    #else
    VPROG_IN_TEXCOORD0(2)
    #endif

    #if defined(MATERIAL_DECAL) || defined(MATERIAL_LIGHTMAP) || defined(FRAME_BLEND) || defined(ALPHA_MASK)
    VPROG_IN_TEXCOORD1(2)
    #endif

    #if defined(VERTEX_COLOR)
    VPROG_IN_COLOR0
    #endif
    
    #if defined(PIXEL_LIT)
    VPROG_IN_TANGENT
    VPROG_IN_BINORMAL
    #endif
    
    #if defined (SKINNING)
    VPROG_IN_BLENDINDEX
    VPROG_IN_BLENDWEIGHT
    #endif


    #if defined(SPEED_TREE_LEAF)
    VPROG_IN_TEXCOORD3(3)
    #if defined(WIND_ANIMATION)
    VPROG_IN_TEXCOORD4(2)
    #endif
    #endif


    
    #if defined(WIND_ANIMATION)
    VPROG_IN_TEXCOORD5(1)
    #endif
/*
    #if defined(FRAME_BLEND)
    attribute float inTime;
    #endif
*/


VPROG_IN_END


////////////////////////////////////////////////////////////////////////////////
// vprog-output

VPROG_OUT_BEGIN

    VPROG_OUT_POSITION

    #if defined(MATERIAL_SKYBOX)
    VPROG_OUT_TEXCOORD0(varTexCoord0,3)
    #else
    VPROG_OUT_TEXCOORD0(varTexCoord0,2)
    #endif

    #if defined(MATERIAL_DECAL) || defined(MATERIAL_LIGHTMAP) || defined(FRAME_BLEND) || defined(ALPHA_MASK)
    VPROG_OUT_TEXCOORD1(varTexCoord1,2)
    #endif

    #if defined(MATERIAL_DETAIL)
    VPROG_OUT_TEXCOORD2(varDetailTexCoord,2)
    #endif

    #if defined(TILED_DECAL_MASK)
    VPROG_OUT_TEXCOORD2(varDecalTileTexCoord,2)
    #endif
    
    
    #if defined(VERTEX_LIT)
        VPROG_OUT_COLOR0(varDiffuseColor,1)
        #if defined(BLINN_PHONG)
            VPROG_OUT_TEXCOORD4(varSpecularColor,1)
            //varying lowp float varSpecularColor;
        #elif defined(NORMALIZED_BLINN_PHONG)
            VPROG_OUT_TEXCOORD4(varSpecularColor,4)
            //varying lowp vec3 varSpecularColor;
            //varying lowp float varNdotH;
        #endif
    #endif

    #if defined(PIXEL_LIT)
zzz        
        varying vec3 varLightPosition;
        varying vec3 varToLightVec;
        varying vec3 varHalfVec;
        varying vec3 varToCameraVec;
        varying float varPerPixelAttenuation;
    #endif

    #if defined(SETUP_LIGHTMAP)
kkk        
        uniform float lightmapSize;
        varying lowp float varLightmapSize;
    #endif
    
    #if defined(VERTEX_COLOR) || defined(SPHERICAL_LIT)
        VPROG_OUT_COLOR1(varVertexColor,4)
    #endif
    
    #if defined(FRAME_BLEND)
        varying lowp float varTime;
    #endif

    #if defined(VERTEX_FOG)
        VPROG_OUT_TEXCOORD5(varFog,4)
//        varying lowp float varFogAmoung;
//        varying lowp vec3 varFogColor;
    #endif



VPROG_OUT_END



////////////////////////////////////////////////////////////////////////////////
// properties

#if !defined SPEED_TREE_LEAF
property float4x4 worldViewProjMatrix : dynamic,a : ;
#endif

#if defined(VERTEX_LIT) || defined(PIXEL_LIT) || defined(VERTEX_FOG) || defined(SPEED_TREE_LEAF) || defined(SPHERICAL_LIT)
property float4x4 worldViewMatrix : dynamic,a : ;
#endif

#if defined(VERTEX_LIT) || defined(PIXEL_LIT) || (defined(VERTEX_FOG) && defined(FOG_ATMOSPHERE))
property float4x4 worldViewInvTransposeMatrix : dynamic,a : ;
property float4 lightPosition0 : dynamic,a : ;
#if defined DISTANCE_ATTENUATION
property float lightIntensity0 : static,a : ; 
#endif
#endif

#if defined(VERTEX_LIT)
property float materialSpecularShininess : dynamic,a : ;
property float inSpecularity : dynamic,a : ;
property float inGlossiness : static,a : ;
property float physicalFresnelReflectance : dynamic,a : ;
property float3 metalFresnelReflectance : dynamic,a : ;
#endif

#if defined (SKINNING)
property float4 jointPositions[MAX_JOINTS] : dynamic,a : ; // (x, y, z, scale)
property float4 jointQuaternions[MAX_JOINTS] : dynamic,a : ;
#endif

#if defined(VERTEX_FOG)
    property float3 fogColor : static,b : ;
    property float fogLimit : static,b : ;
    #if defined(FOG_LINEAR)
    property float fogStart : static,b : ;
    property float fogEnd : static,b : ;
    #else
    property float fogDensity : static,b : ;
    #endif
    #if defined(FOG_ATMOSPHERE)
        property float fogAtmosphereDistance : static,b : ;
        #if defined(FOG_ATMOSPHERE_MAP)
            DECL_SAMPLERCUBE(atmospheremap) : static,b : ;
        #else
            property float3 fogAtmosphereColorSun : static,b : ;
            property float3 fogAtmosphereColorSky : static,b : ;
            property float fogAtmosphereScattering : static,b : ;
        #endif
    #endif
    #if defined(FOG_HALFSPACE)
        property float fogHalfspaceHeight : static,b : ;
        property float fogHalfspaceFalloff : static,b : ;
        property float fogHalfspaceDensity : static,b : ;
        property float fogHalfspaceLimit : static,b : ;
    #endif
#endif

#if defined(MATERIAL_LIGHTMAP)
property float2 uvOffset : static,a : ;
property float2 uvScale : static,a : ;
#endif

#if defined(WIND_ANIMATION)
property float2 trunkOscillationParams : dynamic,a : ;
#endif

#if defined(SPEED_TREE_LEAF)
property float3 worldViewTranslate : static,a : ;
property float3 worldScale : dynamic,a : ;
property float4x4 projMatrix : dynamic,a : ;
property float cutDistance : static,a : ;

    #if !defined(SPHERICAL_LIT) //legacy for old tree lighting
        property float4 treeLeafColorMul : static,a : def_value=0.5,0.5,0.5,0.5 ;
        property float treeLeafOcclusionOffset : static,a : def_value=0 ;
        property float treeLeafOcclusionMul : static,a : def_value=0.5 ;
    #endif
    
    #if defined(WIND_ANIMATION)
        property float2 leafOscillationParams : dynamic,a : ; //x: A*sin(T); y: A*cos(T);
    #endif
    
    #if defined(SPHERICAL_LIT)
        property float speedTreeLightSmoothing : dynamic,a : ;
    #endif
#endif

#if defined(SPHERICAL_LIT)
property float3 worldViewObjectCenter : dynamic,a : ;
property float4x4 invViewMatrix : dynamic,a : ;
property float3 boundingBoxSize : dynamic,a : ;

    #if defined(SPHERICAL_HARMONICS_9)
        property float3 sphericalHarmonics[9] : dynamic,a : ;
    #elif defined(SPHERICAL_HARMONICS_4)
        property float3 sphericalHarmonics[4] : dynamic,a : ;
    #else
        property float3 sphericalHarmonics[1] : dynamic,a : ;
    #endif
    
#endif

#if defined(TILED_DECAL_MASK)
property float2 decalTileCoordScale : dynamic,a : ;
#endif

#if defined(MATERIAL_DETAIL)
property float2 detailTileCoordScale : dynamic,a : ;
#endif

#if defined(TEXTURE0_SHIFT_ENABLED)
property float2 texture0Shift : dynamic,a : ;
#endif 
#if defined(TEXTURE0_ANIMATION_SHIFT)
property float globalTime : dynamic,a : ;
property float2 tex0ShiftPerSecond : dynamic,a : ;
#endif


property float3 cameraPosition : dynamic,a : ;
property float4x4 worldMatrix : dynamic,a : ;





#if defined(WAVE_ANIMATION)
property float globalTime : dynamic,a : ;
#endif



float
FresnelShlick( float NdotL, float Cspec )
{
    float fresnel_exponent = 5.0;
    return (1.0 - Cspec) * pow(1.0 - NdotL, fresnel_exponent) + Cspec;
}

float3
FresnelShlickVec3( float NdotL, float3 Cspec )
{
    float fresnel_exponent = 5.0;
    return (1.0 - Cspec) * (pow(1.0 - NdotL, fresnel_exponent)) + Cspec;
}

float3
JointTransformTangent( float3 inVec, float4 jointQuaternion )
{
    float3 t = 2.0 * cross( jointQuaternion.xyz, inVec );
    return inVec + jointQuaternion.w * t + cross(jointQuaternion.xyz, t); 
}


float4
Wave( float time, float4 pos, float2 uv )
{
//  float time = globalTime;
//  vec4 pos = inPosition;
//  vec2 uv = inTexCoord0;
#if 1
    float4 off;
    float sinOff = pos.x + pos.y + pos.z;
    float t = -time * 3.0;
    float cos1 = cos(t * 1.45 + sinOff);
    float cos2 = cos(t * 3.12 + sinOff);
    float cos3 = cos(t * 2.2 + sinOff);
    float fx= uv.x;
    float fy= uv.x * uv.y;
    
    off.y = pos.y + cos2 * fx * 0.5 - fy * 0.9;
    off.x = pos.x + cos1 * fx * 0.5;
    off.z = pos.z + cos3 * fx * 0.5;
    off.w = pos.w;
#else
    float4 off;
    float t = -time;
    float sin2 = sin(4.0 * sqrt(uv.x + uv.x + uv.y * uv.y) + time);
    
    off.x = pos.x;// + cos1 * fx * 0.5;
    off.y = pos.y + sin2 * 0.5;// - fy * 0.9;
    off.z = pos.z;// + cos3 * fx * 0.5;
    off.w = pos.w;
#endif
    
    return off;
}


////////////////////////////////////////////////////////////////////////////////
// main

VPROG_BEGIN

#if defined (SKINNING)
    // compute final state - for now just effected by 1 bone - later blend everything here
    int     index                    = int(inJointIndex);
    float4  weightedVertexPosition   = jointPositions[index];
    float4  weightedVertexQuaternion = jointQuaternions[index];
#endif

    
    #if defined(SPEED_TREE_LEAF)
    float3 inPivot = VP_IN_TEXCOORD3;
    #if defined(WIND_ANIMATION)
    float2 inAngleSinCos = VP_IN_TEXCOORD4;
    #endif
    #endif
    #if defined(WIND_ANIMATION)
    float inFlexibility = VP_IN_TEXCOORD5;
    #endif

    #if defined(VERTEX_COLOR)
    float4 inVertexColor = VP_IN_COLOR0;
    #endif

#if defined(MATERIAL_SKYBOX)
    
    float4 vecPos = mul( VP_IN_POSITION, worldViewProjMatrix );
    VP_OUT_POSITION = float4(vecPos.xy, vecPos.w - 0.0001, vecPos.w);

#elif defined(SKYOBJECT)
    
    float4x4 mwpWOtranslate = float4x4(worldViewProjMatrix[0], worldViewProjMatrix[1], worldViewProjMatrix[2], float4(0.0, 0.0, 0.0, 1.0));
    float4   vecPos         = mul( float4(VP_IN_POSITION,1.0), mwpWOtranslate );
    VP_OUT_POSITION = float4(vecPos.xy, vecPos.w - 0.0001, vecPos.w);

#elif defined(SPEED_TREE_LEAF)

    float4  eyeCoordsPosition4;

    #if defined (CUT_LEAF)
        float4 tangentInCameraSpace = mul( float4(inPivot,1.0), worldViewMatrix );
        if (tangentInCameraSpace.z < -cutDistance)
        {
            VP_OUT_POSITION = mul( float4(inPivot,VP_IN_POSITION.w), worldViewProjMatrix );
        }
        else
        {
    #endif

            float3 offset = VP_IN_POSITION.xyz - inPivot;
            float3 pivot = inPivot;
            
            
            #if defined(WIND_ANIMATION)
            
            //inAngleSinCos:        x: cos(T0);  y: sin(T0);
            //leafOscillationParams:  x: A*sin(T); y: A*cos(T);
            float3 windVectorFlex = float3(trunkOscillationParams * inFlexibility, 0.0);
            pivot += windVectorFlex;
            
            float2 SinCos = inAngleSinCos * leafOscillationParams; //vec2(A*sin(t)*cos(t0), A*cos(t)*sin(t0))
            float sinT = SinCos.x + SinCos.y;     //sin(t+t0)*A = sin*cos + cos*sin
            float cosT = 1.0 - 0.5 * sinT * sinT; //cos(t+t0)*A = 1 - 0.5*sin^2
            
            float4 SinCosT = float4(sinT, cosT, cosT, sinT); //temp vec for mul
            float4 offsetXY = float4(offset.x, offset.y, offset.x, offset.y); //temp vec for mul
            float4 rotatedOffsetXY = offsetXY * SinCosT; //vec4(x*sin, y*cos, x*cos, y*sin)
            
            offset.x = rotatedOffsetXY.z - rotatedOffsetXY.w; //x*cos - y*sin
            offset.y = rotatedOffsetXY.x + rotatedOffsetXY.y; //x*sin + y*cos

            #endif //end of (not WIND_ANIMATION and SPEED_TREE_LEAF)

            
            float4 eyeCoordsPivot = mul( float4(pivot,1.0), worldViewMatrix );
            eyeCoordsPosition4 = float4(worldScale * offset, 0.0) + eyeCoordsPivot;
            VP_OUT_POSITION = mul(eyeCoordsPosition4,projMatrix);
        
    #if defined (CUT_LEAF)   
        }
    #endif // not CUT_LEAF

#else // not SPEED_TREE_LEAF

    #if defined(WIND_ANIMATION)

        float3 windVectorFlex = float3(trunkOscillationParams * inFlexibility, 0.0);
        VP_OUT_POSITION = mul( float4(VP_IN_POSITION.xyz + windVectorFlex, 1.0), worldViewProjMatrix );
        
    #else //!defined(WIND_ANIMATION)

        #if defined(WAVE_ANIMATION)
            VP_OUT_POSITION = mul( Wave(globalTime, VP_IN_POSITION, inTexCoord0), worldViewProjMatrix );
        #else
            #if defined (SKINNING)
                float3 tmpVec = 2.0 * cross(weightedVertexQuaternion.xyz, VP_IN_POSITION.xyz);
                float4 skinnedPosition = float4(weightedVertexPosition.xyz + (VP_IN_POSITION.xyz + weightedVertexQuaternion.w * tmpVec + cross(weightedVertexQuaternion.xyz, tmpVec))*weightedVertexPosition.w, VP_IN_POSITION.w);
                VP_OUT_POSITION = mul( skinnedPosition, worldViewProjMatrix );
            #else
                VP_OUT_POSITION = mul( float4(VP_IN_POSITION,1.0), worldViewProjMatrix );
            #endif
        #endif

    #endif //defined(WIND_ANIMATION)

#endif //end "not SPEED_TREE_LEAF


#if defined(SPEED_TREE_LEAF)
    float3 eyeCoordsPosition = eyeCoordsPosition4.xyz;
#elif defined(VERTEX_LIT) || defined(PIXEL_LIT) || defined(VERTEX_FOG) || defined(SPHERICAL_LIT)
    #if defined (SKINNING)
        float3 eyeCoordsPosition = mul( skinnedPosition, worldViewMatrix ).xyz; // view direction in view space
    #else
        // view direction in view space
        float3 eyeCoordsPosition = mul( float4(VP_IN_POSITION,1.0), worldViewMatrix ).xyz; 
    #endif
#endif


#if defined(VERTEX_LIT) || defined(PIXEL_LIT) || (defined(VERTEX_FOG) && defined(FOG_ATMOSPHERE))
    float3 toLightDir = lightPosition0.xyz - eyeCoordsPosition * lightPosition0.w;
#endif


#if defined(VERTEX_LIT)
    
    float3 normal = normalize(worldViewInvTransposeMatrix * inNormal); // normal in eye coordinates
   
    #if defined(DISTANCE_ATTENUATION)
        float attenuation = lightIntensity0;
        float distAttenuation = length(toLightDir);
        attenuation /= (distAttenuation * distAttenuation); // use inverse distance for distance attenuation
    #endif
    
    toLightDir = normalize(toLightDir);
    
    
    #if defined(BLINN_PHONG)
        
        varDiffuseColor = max(0.0, dot(normal, toLightDir));

        // Blinn-phong reflection
        float3 toCameraDir = normalize(-eyeCoordsPosition);
        float3 H = normalize(toLightDir + toCameraDir);
        float nDotHV = max(0.0, dot(normal, H));
        varSpecularColor = pow(nDotHV, materialSpecularShininess);
        
    #elif defined(NORMALIZED_BLINN_PHONG)
        
        float3 toCameraNormalized = normalize(-eyeCoordsPosition);
        float3 H = normalize(toLightDir + toCameraNormalized);

        float NdotL = max (dot (normal, toLightDir), 0.0);
        float NdotH = max (dot (normal, H), 0.0);
        float LdotH = max (dot (toLightDir, H), 0.0);
        float NdotV = max (dot (normal, toCameraNormalized), 0.0);

        //float3 fresnelIn = FresnelShlickVec3(NdotL, metalFresnelReflectance);
        float3 fresnelOut  = FresnelShlickVec3(NdotV, metalFresnelReflectance);
        float  specularity = inSpecularity;

        float Dbp = NdotL;
        float Geo = 1.0 / LdotH * LdotH;
        
        varDiffuseColor = NdotL / _PI;
        
        varSpecularColor = Dbp * Geo * fresnelOut * specularity;
        /*varNdotH*/varSpecularColor.w = NdotH;
    
    #endif
    
#endif // defined(VERTEX_LIT)


#if defined(PIXEL_LIT)

    #if defined (SKINNING)
        float3 n = normalize (worldViewInvTransposeMatrix * JointTransformTangent(inNormal, weightedVertexQuaternion));
        float3 t = normalize (worldViewInvTransposeMatrix * JointTransformTangent(inTangent, weightedVertexQuaternion));
        float3 b = normalize (worldViewInvTransposeMatrix * JointTransformTangent(inBinormal, weightedVertexQuaternion));
    #else
        float3 n = normalize (worldViewInvTransposeMatrix * inNormal);
        float3 t = normalize (worldViewInvTransposeMatrix * inTangent);
        float3 b = normalize (worldViewInvTransposeMatrix * inBinormal);
    #endif
    
    #if defined(DISTANCE_ATTENUATION)
        varPerPixelAttenuation = length(toLightDir);
    #endif
    //lightDir = normalize(lightDir);
    
    // transform light and half angle vectors by tangent basis
    float3 v;
    v.x = dot (toLightDir, t);
    v.y = dot (toLightDir, b);
    v.z = dot (toLightDir, n);
    
    #if !defined(FAST_NORMALIZATION)
        varToLightVec = v;
    #else
        varToLightVec = normalize(v);
    #endif

    float3 toCameraDir = -eyeCoordsPosition;

    v.x = dot (toCameraDir, t);
    v.y = dot (toCameraDir, b);
    v.z = dot (toCameraDir, n);
    
    #if !defined(FAST_NORMALIZATION)
        varToCameraVec = v;
    #else
        varToCameraVec = normalize(v);
    #endif
    
    /* Normalize the halfVector to pass it to the fragment shader */
    // No need to divide by two, the result is normalized anyway.
    // float3 halfVector = normalize((E + lightDir) / 2.0);
    #if defined(FAST_NORMALIZATION)
        float3 halfVector = normalize(normalize(toCameraDir) + normalize(toLightDir));
        v.x = dot (halfVector, t);
        v.y = dot (halfVector, b);
        v.z = dot (halfVector, n);
        
        // No need to normalize, t,b,n and halfVector are normal vectors.
        varHalfVec = v;
    #endif

//    varLightPosition.x = dot (lightPosition0.xyz, t);
//    varLightPosition.y = dot (lightPosition0.xyz, b);
//    varLightPosition.z = dot (lightPosition0.xyz, n);
    

#endif // defined(PIXEL_LIT)


#if defined(VERTEX_FOG)

    float fogDistance = length(eyeCoordsPosition);
    
    // calculating fog amoung, depending on distance 
    #if !defined(FOG_LINEAR)
        VP_OUT(varFog).w = 1.0 - exp(-fogDensity * fogDistance);
    #else
        VP_OUT(varFog).w = (fogDistance - fogStart) / (fogEnd - fogStart);
    #endif
    
    // calculating view direction in world space, point of view in world space
    #if defined(FOG_HALFSPACE) || defined(FOG_ATMOSPHERE_MAP)
        float3 viewPointInWorldSpace = mul(VP_IN_POSITION,worldMatrix).xyz;
        float3 viewDirectionInWorldSpace = viewPointInWorldSpace - cameraPosition;
    #endif
    
    // calculating halfSpaceFog amoung
    #if defined(FOG_HALFSPACE)
        #if defined(FOG_HALFSPACE_LINEAR)
            // view http://www.terathon.com/lengyel/Lengyel-UnifiedFog.pdf
            // to get more clear understanding about this calculations
            float fogK = step(cameraPosition.z, fogHalfspaceHeight);
            float fogFdotP = viewPointInWorldSpace.z - fogHalfspaceHeight;
            float fogFdotC = cameraPosition.z - fogHalfspaceHeight;
            
            float fogC1 = fogK * (fogFdotP + fogFdotC);
            float fogC2 = (1.0 - 2.0 * fogK) * fogFdotP;
            float fogG = min(fogC2, 0.0);
            fogG = -length(viewDirectionInWorldSpace) * fogHalfspaceDensity * (fogC1 - fogG * fogG / abs(viewDirectionInWorldSpace.z));
            
            float halfSpaceFogAmoung = 1.0 - exp2(-fogG);
        #else
            float fogK = viewDirectionInWorldSpace.z / fogDistance;
            float fogB = cameraPosition.z - fogHalfspaceHeight;
            
            float halfSpaceFogAmoung = fogHalfspaceDensity * exp(-fogHalfspaceFalloff * fogB) * (1.0 - exp(-fogHalfspaceFalloff * fogK * fogDistance)) / fogK;
        #endif
        VP_OUT(varFog).w = VP_OUT(varFog).a + clamp(halfSpaceFogAmoung, 0.0, fogHalfspaceLimit);
    #endif

    // limit fog amoung
    VP_OUT(varFog).w = clamp(VP_OUT(varFog).w, 0.0, fogLimit);
    
    // calculating fog color
    #if defined(FOG_ATMOSPHERE)
        float3 atmosphereColor;
        #if defined(FOG_ATMOSPHERE_MAP)
            float3 viewDirection = normalize(float3(mul(VP_IN_POSITION,worldMatrix)) - cameraPosition);
            viewDirection.z = clamp(viewDirection.z, 0.01, 1.0);
            atmosphereColor = textureCube(atmospheremap, viewDirection).xyz;
        #else
            float atmospheteAngleFactor = dot(normalize(eyeCoordsPosition), normalize(toLightDir)) * 0.5 + 0.5;
            atmosphereColor = lerp(fogAtmosphereColorSky, fogAtmosphereColorSun, pow(atmospheteAngleFactor, fogAtmosphereScattering));
        #endif
        float fogAtmosphereAttenuation = clamp(fogDistance / fogAtmosphereDistance, 0.0, 1.0);
        VP_OUT(varFog).xyz = lerp(fogColor, atmosphereColor, fogAtmosphereAttenuation);
    #else
        VP_OUT(varFog).xyz = fogColor;
    #endif

#endif // defined(VERTEX_FOG)


#if defined(VERTEX_COLOR)
    VP_OUT(varVertexColor) = VP_IN_COLOR0;
#endif


#if defined(SPHERICAL_LIT)

    #define A0      (0.282094)
    #define A1      (0.325734)

    #define Y2_2(n) (0.273136 * (n.y * n.x))                                // (1.0 / 2.0) * sqrt(15.0 / PI) * ((n.y * n.x)) * 0.785398 / PI
    #define Y2_1(n) (0.273136 * (n.y * n.z))                                // (1.0 / 2.0) * sqrt(15.0 / PI) * ((n.y * n.z)) * 0.785398 / PI
    #define Y20(n)  (0.078847 * (3.0 * n.z * n.z - 1.0))                    // (1.0 / 4.0) * sqrt(5.0 / PI) * ((3.0 * n.z * n.z - 1.0)) * 0.785398 / PI
    #define Y21(n)  (0.273136 * (n.z * n.x))                                // (1.0 / 2.0) * sqrt(15.0 / PI) * ((n.z * n.x)) * 0.785398 / PI
    #define Y22(n)  (0.136568 * (n.x * n.x - n.y * n.y))                    // (1.0 / 4.0) * sqrt(15.0 / PI) * ((n.x * n.x - n.y * n.y)) * 0.785398 / PI

    float3 sphericalLightFactor = A0 * sphericalHarmonics[0];
    
    #if defined(SPEED_TREE_LEAF)
        float3 localSphericalLightFactor = sphericalLightFactor;
    #endif
    
    #if !defined(CUT_LEAF)

        #if defined(SPHERICAL_HARMONICS_4) || defined(SPHERICAL_HARMONICS_9)

            float3x3 invViewMatrix3 = float3x3(float3(invViewMatrix[0]), float3(invViewMatrix[1]), float3(invViewMatrix[2]));
            float3 normal = invViewMatrix3 * (eyeCoordsPosition - worldViewObjectCenter);
            normal /= boundingBoxSize;
            float3 n = normalize(normal);

            float3x3 shMatrix = float3x3(sphericalHarmonics[1], sphericalHarmonics[2], sphericalHarmonics[3]);
            sphericalLightFactor += A1 * shMatrix * float3(n.y, n.z, n.x);
        
            #if defined(SPEED_TREE_LEAF)
                float3 localNormal = mul( (eyeCoordsPosition - float3(eyeCoordsPivot)), invViewMatrix3 );
                float3 ln = normalize(localNormal);
                localSphericalLightFactor += A1 * shMatrix * float3(ln.y, ln.z, ln.x);
            #endif

            #if defined(SPHERICAL_HARMONICS_9)
                sphericalLightFactor += Y2_2(n) * sphericalHarmonics[4];
                sphericalLightFactor += Y2_1(n) * sphericalHarmonics[5];
                sphericalLightFactor += Y20(n) * sphericalHarmonics[6];
                sphericalLightFactor += Y21(n) * sphericalHarmonics[7];
                sphericalLightFactor += Y22(n) * sphericalHarmonics[8];
            #endif

            #if defined(SPEED_TREE_LEAF)
                sphericalLightFactor = lerp(sphericalLightFactor, localSphericalLightFactor, speedTreeLightSmoothing);
            #endif
        
        #endif // defined(SPHERICAL_HARMONICS_4) || defined(SPHERICAL_HARMONICS_9)

    #endif // !defined(CUT_LEAF)

    VP_OUT(varVertexColor) = float4(sphericalLightFactor * 2.0, 1.0);

    #undef A0     
    #undef A1     

    #undef Y2_2
    #undef Y2_1
    #undef Y20 
    #undef Y21 
    #undef Y22 

#elif defined(SPEED_TREE_LEAF) //legacy for old tree lighting
    
    VP_OUT(varVertexColor).xyz = inVertexColor.xyz * treeLeafColorMul.xyz * treeLeafOcclusionMul + float3(treeLeafOcclusionOffset,treeLeafOcclusionOffset,treeLeafOcclusionOffset);

#endif


    VP_OUT(varTexCoord0) = VP_IN_TEXCOORD0;
    

#if defined(TEXTURE0_SHIFT_ENABLED)
    VP_OUT(varTexCoord0) += texture0Shift;
#endif

    
#if defined(TEXTURE0_ANIMATION_SHIFT)
    VP_OUT(varTexCoord0) += tex0ShiftPerSecond * globalTime;
#endif

    
#if defined(TILED_DECAL_MASK)
    varDecalTileTexCoord = VP_OUT(varTexCoord0) * decalTileCoordScale;
#endif

    
#if defined(MATERIAL_DETAIL)
    varDetailTexCoord = VP_OUT(varTexCoord0) * detailTileCoordScale;
#endif


#if defined(MATERIAL_DECAL) || defined(MATERIAL_LIGHTMAP) || defined(FRAME_BLEND) || defined(ALPHA_MASK)
    
    #if defined(SETUP_LIGHTMAP)
        varLightmapSize      = lightmapSize;
        VP_OUT(varTexCoord1) = VP_IN_TEXCOORD1;
    #elif defined(MATERIAL_LIGHTMAP)
        VP_OUT(varTexCoord1) = uvScale*VP_IN_TEXCOORD1 + uvOffset;
    #else
        VP_OUT(varTexCoord1) = VP_IN_TEXCOORD1;
    #endif
#endif


#if defined(FRAME_BLEND)
    varTime = inTime;
#endif

VPROG_END




